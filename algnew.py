# -*- coding: utf-8 -*-
"""algnew

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yjEv5w_xwt17pyE4d4xFyjNgry05PTu3
"""

# Commented out IPython magic to ensure Python compatibility.
import heapq
import time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from IPython.display import display, HTML
import math
import ipywidgets as widgets
from google.colab import output

# %matplotlib inline
output.enable_custom_widget_manager()

class Constants:
    EMPTY = 0
    OBSTACLE = 1
    START = 2
    GOAL = 3
    PATH = 4
    EXPLORED = 5
    FRONTIER = 6
    DRONE = 7

    COLOR_MAP = {
        EMPTY: 'white',
        OBSTACLE: '#3A3A3A',
        START: '#4CAF50',
        GOAL: '#F44336',
        PATH: '#2196F3',
        EXPLORED: '#B3E5FC',
        FRONTIER: '#FFECB3',
        DRONE: '#9C27B0'
    }

    MOVE_STRAIGHT_COST = 1.0
    MOVE_DIAGONAL_COST = 1.4

class PriorityQueue:
    def __init__(self):
        self.elements = []

    def empty(self):
        return len(self.elements) == 0

    def put(self, item):
        heapq.heappush(self.elements, item)

    def get(self):
        return heapq.heappop(self.elements)

class PathfindingVisualizer:
    def __init__(self, grid_size=(15, 15)):
        self.rows, self.cols = grid_size
        self.grid = np.zeros((self.rows, self.cols))
        self.start_pos = None
        self.goal_pos = None
        self.drone_positions = []
        self.path = []
        self.explored = set()
        self.frontier = []
        self.animation_speed = 0.1
        self.setup_ui()

    def setup_ui(self):
        self.fig, self.ax = plt.subplots(figsize=(10, 8))

        # Create widgets
        self.btn_run = widgets.Button(description='Run A*', button_style='success')
        self.btn_run.on_click(self.run_algorithm)

        # Position inputs
        self.start_row = widgets.IntText(description='Start Row:', min=0, max=self.rows-1)
        self.start_col = widgets.IntText(description='Start Col:', min=0, max=self.cols-1)
        self.goal_row = widgets.IntText(description='Goal Row:', min=0, max=self.rows-1)
        self.goal_col = widgets.IntText(description='Goal Col:', min=0, max=self.cols-1)

        # Placement controls
        self.drawing_choice = widgets.RadioButtons(
            options=['Obstacle', 'Drone'],
            value='Obstacle',
            description='Draw:'
        )

        self.place_row = widgets.IntText(description='Row:', min=0, max=self.rows-1)
        self.place_col = widgets.IntText(description='Col:', min=0, max=self.cols-1)
        self.place_btn = widgets.Button(description='Place', button_style='primary')
        self.place_btn.on_click(self.handle_placement)

        # Create guide text
        guide_text = """
        <div style="background-color: #e0f7fa; padding: 15px; border-radius: 8px; margin-top: 10px;">
        <h3 style="color: #006064;">How to Use This Visualizer</h3>
        <ol style="font-size: 14px; color: #00363a;">
        <li><b>Set Positions:</b> Enter row and column for Start and Goal positions</li>
        <li><b>Place Elements:</b>
            <ul>
                <li>Select 'Obstacle' to place impassable walls (black)</li>
                <li>Select 'Drone' to place points of interest (purple)</li>
            </ul>
        </li>
        <li><b>Run Algorithm:</b> Click 'Run A*' to find the optimal path</li>
        </ol>
        <h4 style="color: #006064;">Visual Legend</h4>
        <ul style="font-size: 14px; color: #00363a;">
        <li><span style="color: #4CAF50;">■</span> Start - Where path begins</li>
        <li><span style="color: #F44336;">■</span> Goal - Destination</li>
        <li><span style="color: #3A3A3A;">■</span> Obstacle - Cannot pass through</li>
        <li><span style="color: #9C27B0;">■</span> Drone - Points of interest</li>
        <li><span style="color: #2196F3;">■</span> Path - Optimal route found</li>
        <li><span style="color: #B3E5FC;">■</span> Explored - Checked nodes</li>
        <li><span style="color: #FFECB3;">■</span> Frontier - Nodes to explore</li>
        </ul>
        </div>
        """
        self.guide = widgets.HTML(value=guide_text)

        # Layout
        controls = widgets.VBox([
            widgets.HTML("<h3>Set Positions</h3>"),
            widgets.HBox([self.start_row, self.start_col]),
            widgets.HBox([self.goal_row, self.goal_col]),
            widgets.HTML("<h3>Place Elements</h3>"),
            self.drawing_choice,
            widgets.HBox([self.place_row, self.place_col]),
            self.place_btn,
            self.btn_run,
            self.guide
        ])

        display(controls)
        self.draw_grid()

    def handle_placement(self, b):
        row, col = self.place_row.value, self.place_col.value

        if self.drawing_choice.value == 'Obstacle':
            self.grid[row, col] = Constants.OBSTACLE
        elif self.drawing_choice.value == 'Drone':
            if (row, col) not in self.drone_positions:
                self.drone_positions.append((row, col))

        # Update start/goal if they were placed
        if self.start_row.value is not None and self.start_col.value is not None:
            self.start_pos = (self.start_row.value, self.start_col.value)
            self.grid[self.start_pos[0], self.start_pos[1]] = Constants.START

        if self.goal_row.value is not None and self.goal_col.value is not None:
            self.goal_pos = (self.goal_row.value, self.goal_col.value)
            self.grid[self.goal_pos[0], self.goal_pos[1]] = Constants.GOAL

        self.draw_grid()

    def draw_grid(self):
        self.ax.clear()

        # Create color grid
        color_grid = np.zeros((self.rows, self.cols, 3))
        for i in range(self.rows):
            for j in range(self.cols):
                color_grid[i, j] = mcolors.to_rgb(Constants.COLOR_MAP[int(self.grid[i, j])])

        # Mark explored and frontier
        for (i, j) in self.explored:
            if (i, j) not in [self.start_pos, self.goal_pos] and (i, j) not in self.drone_positions:
                color_grid[i, j] = mcolors.to_rgb(Constants.COLOR_MAP[Constants.EXPLORED])

        for (i, j) in self.frontier:
            if (i, j) not in [self.start_pos, self.goal_pos] and (i, j) not in self.drone_positions:
                color_grid[i, j] = mcolors.to_rgb(Constants.COLOR_MAP[Constants.FRONTIER])

        # Draw path
        for (i, j) in self.path:
            if (i, j) not in [self.start_pos, self.goal_pos] and (i, j) not in self.drone_positions:
                color_grid[i, j] = mcolors.to_rgb(Constants.COLOR_MAP[Constants.PATH])

        # Display the grid
        self.ax.imshow(color_grid, origin='upper')

        # Add grid lines
        for i in range(self.rows + 1):
            self.ax.axhline(i - 0.5, color='gray', linewidth=0.5)
        for j in range(self.cols + 1):
            self.ax.axvline(j - 0.5, color='gray', linewidth=0.5)

        # Mark start and goal if they exist
        if self.start_pos:
            self.ax.text(self.start_pos[1], self.start_pos[0], "S",
                        ha='center', va='center', color='white',
                        fontsize=12, weight='bold',
                        bbox=dict(facecolor=Constants.COLOR_MAP[Constants.START],
                                edgecolor='black', boxstyle='circle'))

        if self.goal_pos:
            self.ax.text(self.goal_pos[1], self.goal_pos[0], "G",
                        ha='center', va='center', color='white',
                        fontsize=12, weight='bold',
                        bbox=dict(facecolor=Constants.COLOR_MAP[Constants.GOAL],
                                edgecolor='black', boxstyle='circle'))

        # Mark drones
        for (i, j) in self.drone_positions:
            self.ax.text(j, i, "D",
                        ha='center', va='center', color='white',
                        fontsize=12, weight='bold',
                        bbox=dict(facecolor=Constants.COLOR_MAP[Constants.DRONE],
                                edgecolor='black', boxstyle='circle'))

        self.ax.set_xticks(np.arange(self.cols))
        self.ax.set_yticks(np.arange(self.rows))
        self.ax.set_title("A* Pathfinding Visualization")
        display(self.fig)
        plt.close(self.fig)

    def run_algorithm(self, b):
        if not self.start_pos or not self.goal_pos:
            print("Please set both start and goal positions!")
            return

        self.path = []
        self.explored = set()
        self.frontier = []
        self.draw_grid()

        path, cost = self.a_star_search()
        if path:
            self.path = path
            print(f"Path found! Cost: {cost:.2f}, Length: {len(path)} steps")
        else:
            print("No path found!")

        self.draw_grid()

    def get_neighbors(self, pos):
        row, col = pos
        neighbors = []
        directions = [(-1,0), (1,0), (0,-1), (0,1),  # 4-directional
                     (-1,-1), (-1,1), (1,-1), (1,1)]  # 8-directional

        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            if 0 <= nr < self.rows and 0 <= nc < self.cols and self.grid[nr, nc] != Constants.OBSTACLE:
                cost = Constants.MOVE_DIAGONAL_COST if abs(dr) + abs(dc) == 2 else Constants.MOVE_STRAIGHT_COST
                neighbors.append(((nr, nc), cost))

        return neighbors

    def heuristic(self, a, b):
        return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)  # Euclidean

    def a_star_search(self):
        open_set = PriorityQueue()
        open_set.put((0, self.start_pos))

        came_from = {}
        g_score = {self.start_pos: 0}
        f_score = {self.start_pos: self.heuristic(self.start_pos, self.goal_pos)}

        self.frontier = [self.start_pos]

        while not open_set.empty():
            current_f, current = open_set.get()

            if current == self.goal_pos:
                return self.reconstruct_path(came_from, current), g_score[current]

            self.explored.add(current)
            if current in self.frontier:
                self.frontier.remove(current)

            for neighbor, cost in self.get_neighbors(current):
                tentative_g = g_score[current] + cost

                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, self.goal_pos)
                    open_set.put((f_score[neighbor], neighbor))
                    if neighbor not in self.frontier:
                        self.frontier.append(neighbor)

            self.draw_grid()
            time.sleep(self.animation_speed)

        return None, float('inf')

    def reconstruct_path(self, came_from, current):
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        path.reverse()
        return path

# Run the visualizer
visualizer = PathfindingVisualizer(grid_size=(15, 15))